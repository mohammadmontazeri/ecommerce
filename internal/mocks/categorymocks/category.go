// Code generated by mockery v2.38.0. DO NOT EDIT.

package categorymocks

import (
	models "ecommerce/models"

	mock "github.com/stretchr/testify/mock"
)

// CategoryRepository is an autogenerated mock type for the CategoryRepository type
type CategoryRepository struct {
	mock.Mock
}

type CategoryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *CategoryRepository) EXPECT() *CategoryRepository_Expecter {
	return &CategoryRepository_Expecter{mock: &_m.Mock}
}

// DeleteRow provides a mock function with given fields: category, categoryID
func (_m *CategoryRepository) DeleteRow(category models.Category, categoryID int) error {
	ret := _m.Called(category, categoryID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(models.Category, int) error); ok {
		r0 = rf(category, categoryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CategoryRepository_DeleteRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRow'
type CategoryRepository_DeleteRow_Call struct {
	*mock.Call
}

// DeleteRow is a helper method to define mock.On call
//   - category models.Category
//   - categoryID int
func (_e *CategoryRepository_Expecter) DeleteRow(category interface{}, categoryID interface{}) *CategoryRepository_DeleteRow_Call {
	return &CategoryRepository_DeleteRow_Call{Call: _e.mock.On("DeleteRow", category, categoryID)}
}

func (_c *CategoryRepository_DeleteRow_Call) Run(run func(category models.Category, categoryID int)) *CategoryRepository_DeleteRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Category), args[1].(int))
	})
	return _c
}

func (_c *CategoryRepository_DeleteRow_Call) Return(_a0 error) *CategoryRepository_DeleteRow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CategoryRepository_DeleteRow_Call) RunAndReturn(run func(models.Category, int) error) *CategoryRepository_DeleteRow_Call {
	_c.Call.Return(run)
	return _c
}

// GetCategory provides a mock function with given fields: category, categoryID
func (_m *CategoryRepository) GetCategory(category models.Category, categoryID int) (models.Category, error) {
	ret := _m.Called(category, categoryID)

	if len(ret) == 0 {
		panic("no return value specified for GetCategory")
	}

	var r0 models.Category
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Category, int) (models.Category, error)); ok {
		return rf(category, categoryID)
	}
	if rf, ok := ret.Get(0).(func(models.Category, int) models.Category); ok {
		r0 = rf(category, categoryID)
	} else {
		r0 = ret.Get(0).(models.Category)
	}

	if rf, ok := ret.Get(1).(func(models.Category, int) error); ok {
		r1 = rf(category, categoryID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CategoryRepository_GetCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCategory'
type CategoryRepository_GetCategory_Call struct {
	*mock.Call
}

// GetCategory is a helper method to define mock.On call
//   - category models.Category
//   - categoryID int
func (_e *CategoryRepository_Expecter) GetCategory(category interface{}, categoryID interface{}) *CategoryRepository_GetCategory_Call {
	return &CategoryRepository_GetCategory_Call{Call: _e.mock.On("GetCategory", category, categoryID)}
}

func (_c *CategoryRepository_GetCategory_Call) Run(run func(category models.Category, categoryID int)) *CategoryRepository_GetCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Category), args[1].(int))
	})
	return _c
}

func (_c *CategoryRepository_GetCategory_Call) Return(_a0 models.Category, _a1 error) *CategoryRepository_GetCategory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *CategoryRepository_GetCategory_Call) RunAndReturn(run func(models.Category, int) (models.Category, error)) *CategoryRepository_GetCategory_Call {
	_c.Call.Return(run)
	return _c
}

// InsertCategory provides a mock function with given fields: input
func (_m *CategoryRepository) InsertCategory(input models.Category) error {
	ret := _m.Called(input)

	if len(ret) == 0 {
		panic("no return value specified for InsertCategory")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(models.Category) error); ok {
		r0 = rf(input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CategoryRepository_InsertCategory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InsertCategory'
type CategoryRepository_InsertCategory_Call struct {
	*mock.Call
}

// InsertCategory is a helper method to define mock.On call
//   - input models.Category
func (_e *CategoryRepository_Expecter) InsertCategory(input interface{}) *CategoryRepository_InsertCategory_Call {
	return &CategoryRepository_InsertCategory_Call{Call: _e.mock.On("InsertCategory", input)}
}

func (_c *CategoryRepository_InsertCategory_Call) Run(run func(input models.Category)) *CategoryRepository_InsertCategory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Category))
	})
	return _c
}

func (_c *CategoryRepository_InsertCategory_Call) Return(_a0 error) *CategoryRepository_InsertCategory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CategoryRepository_InsertCategory_Call) RunAndReturn(run func(models.Category) error) *CategoryRepository_InsertCategory_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRow provides a mock function with given fields: category, categoryID
func (_m *CategoryRepository) UpdateRow(category models.Category, categoryID int) error {
	ret := _m.Called(category, categoryID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(models.Category, int) error); ok {
		r0 = rf(category, categoryID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CategoryRepository_UpdateRow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRow'
type CategoryRepository_UpdateRow_Call struct {
	*mock.Call
}

// UpdateRow is a helper method to define mock.On call
//   - category models.Category
//   - categoryID int
func (_e *CategoryRepository_Expecter) UpdateRow(category interface{}, categoryID interface{}) *CategoryRepository_UpdateRow_Call {
	return &CategoryRepository_UpdateRow_Call{Call: _e.mock.On("UpdateRow", category, categoryID)}
}

func (_c *CategoryRepository_UpdateRow_Call) Run(run func(category models.Category, categoryID int)) *CategoryRepository_UpdateRow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Category), args[1].(int))
	})
	return _c
}

func (_c *CategoryRepository_UpdateRow_Call) Return(_a0 error) *CategoryRepository_UpdateRow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *CategoryRepository_UpdateRow_Call) RunAndReturn(run func(models.Category, int) error) *CategoryRepository_UpdateRow_Call {
	_c.Call.Return(run)
	return _c
}

// NewCategoryRepository creates a new instance of CategoryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCategoryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *CategoryRepository {
	mock := &CategoryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
